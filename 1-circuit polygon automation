from sage.all import *
# Algorithm that takes the number of sides/vertices S and prints a polygon with circuit diameter 1
def Automation(S):
    #declare a ring for the polynomials
    R.<x> = QQ[]
    #count is the number of polynomials needed to plot the polygon
    count = (S - 3)/2
    #declare a matrix to hold the polynomials that will give the coordinates of the polytope
    M = zero_matrix(R,count+1,2)
    #set the first and second coordinate
    M[0] = [1,0]
    M[1] = [x,1]
    #variable to be used in the next loop
    b = x
    #loop to generate the rest of the polynomials needed in terms of x (the first coordinate)
    for i in range(2,count+1):
        a = M[ceil(i/2),0] - M[i//2 - 1,0]
        M[i] = [a * b,M[i-1,0]]
        b = a
    #declare a matrix to hold the coordinates of the polytope and set the origin as the first vertex
    Coordinates = zero_matrix(R,S,2)
    Coordinates[0] = [0,0]
    #loop to assign the proper polynomials to the coodinates of the polytope
    for i in range(1,S,2):
        Coordinates[i] = M[(i-1)/2]
        Coordinates[i+1] = [M[(i-1)/2,1],M[(i-1)/2,0]]
    #calculate the polynomial whose roots will give us possible values for x (our first coordinate)
    f = x*(M[count,0] - M[count-1,0]) - (M[count-1,0] - M[count-1,1])
    #generate all roots (all possible values for x)
    m = f.roots(ring=QQbar)
    #store the number of roots
    length = len(m)
    #declare an empty list to store the roots which maintain convexity of the polytope
    GoodRoots = []
    #loop that runs through all roots
    for i in range(0,length):
        #variable used for stopping conditions
        h = 0
        #loop with the stopping condition (set h = 1 if we break convexity)
        while (h == 0):
            #check that x is beyond (1,0)
            if m[i][0] < 1:
                #stopping condition
                h = 1
            #check that each slope is greater than the previous slope (to maintain convexity)
            else:
                #starting vertex
                j = 3
                #check all vertices on one side of the polytope
                while (j < S - 2):
                    #generate the slopes
                    slope1 = (Coordinates[j+2][1](m[i][0])- Coordinates[j][1])(m[i][0])/(Coordinates[j+2][0](m[i][0])- Coordinates[j][0](m[i][0]))
                    slope2 = (Coordinates[j-2][1](m[i][0])- Coordinates[j][1])(m[i][0])/(Coordinates[j-2][0](m[i][0])- Coordinates[j][0](m[i][0]))
                    #check the slopes are positive
                    if slope1 < 0:
                        #stopping condition
                        h = 1
                        j = S - 2
                        #check the slopes are increasing
                    if slope1 < slope2:
                        #stopping condition
                        h = 1
                        j = S - 2
                    #if not stopped, check the next vertex
                    j = j+2
            #check the stopping condition
            if h == 0:
                #add the root to the list
                GoodRoots.append(m[i][0])
                #stopping condition
                h = 1
    #loop through all roots that maintain convexity and generate a polytope with those roots
    for r in GoodRoots:
        #declare a matrix to hold the coordiantes
        V = zero_matrix(RR,S,2)
        #loop through all vertices
        for j in range(0,S):
            #assign vertex coordiantes by plugging in root to all polynomials
            V[j,0] = Coordinates[j,0](r)
            V[j,1] = Coordinates[j,1](r)
        #declare the polygon and print it
        P = Polyhedron(V)
        P.show()
